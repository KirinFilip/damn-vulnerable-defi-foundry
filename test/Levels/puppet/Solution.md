The lending pool uses a uniswap v1 oracle to fetch the price of ETH / DVT token. Private function `_computeOraclePrice()` calculates the price of the DVT token in wei. The function uses integer division which can be gamed. When using integer division in solidity, since solidity does not use floating points, we get wrong results using division sometimes. E.g. `5/3 = 1.667`, rounded up is 2 but solidity does not round up, it discards everything after the floating point, meaning in solidity `5/3 = 1`, `-5/3 = -1` and so on. Therefore in `_computeOraclePrice()` which uses the formula `(uniswapPair.balance (10 ** 18)) / token.balanceOf(uniswapPair);` this will not return a good price due to integer division as soon as the poolâ€™s DVT token balance > ETH balance. A correct implementation should multiply by the borrowAmount first before dividing by the token balance to circumvent this issue. From there the exploit is pretty simple. Swap DVT to ETH - such that DVT balance > ETH balance in the uniswap v1 pool. Lastly, borrow all the DVT tokens in the lending pool at zero price.
